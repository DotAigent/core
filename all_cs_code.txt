===== START OF FILE: ./src/DotAigent.Core/obj/Debug/net9.0/DotAigent.Core.GlobalUsings.g.cs =====
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
===== END OF FILE: ./src/DotAigent.Core/obj/Debug/net9.0/DotAigent.Core.GlobalUsings.g.cs =====

===== START OF FILE: ./src/DotAigent.Core/obj/Debug/net9.0/.NETCoreApp,Version=v9.0.AssemblyAttributes.cs =====
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName = ".NET 9.0")]
===== END OF FILE: ./src/DotAigent.Core/obj/Debug/net9.0/.NETCoreApp,Version=v9.0.AssemblyAttributes.cs =====

===== START OF FILE: ./src/DotAigent.Core/obj/Debug/net9.0/DotAigent.Core.AssemblyInfo.cs =====
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DotAiAgent")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyDescriptionAttribute("Core interfaces and classes for DotAiAgent")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+1a55f8e44862eb57d8097545997aa970c68057d0")]
[assembly: System.Reflection.AssemblyProductAttribute("DotAigent.Core")]
[assembly: System.Reflection.AssemblyTitleAttribute("DotAigent.Core")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.

===== END OF FILE: ./src/DotAigent.Core/obj/Debug/net9.0/DotAigent.Core.AssemblyInfo.cs =====

===== START OF FILE: ./src/DotAigent.Core/obj/Debug/netstandard2.0/DotAigent.Core.GlobalUsings.g.cs =====
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
===== END OF FILE: ./src/DotAigent.Core/obj/Debug/netstandard2.0/DotAigent.Core.GlobalUsings.g.cs =====

===== START OF FILE: ./src/DotAigent.Core/obj/Debug/netstandard2.0/.NETStandard,Version=v2.0.AssemblyAttributes.cs =====
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETStandard,Version=v2.0", FrameworkDisplayName = ".NET Standard 2.0")]
===== END OF FILE: ./src/DotAigent.Core/obj/Debug/netstandard2.0/.NETStandard,Version=v2.0.AssemblyAttributes.cs =====

===== START OF FILE: ./src/DotAigent.Core/obj/Debug/netstandard2.0/DotAigent.Core.AssemblyInfo.cs =====
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DotAiAgent")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyDescriptionAttribute("Core interfaces and classes for DotAiAgent")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+7d1dd7ce02d713d113cc3514ee9a20ce0d000281")]
[assembly: System.Reflection.AssemblyProductAttribute("DotAigent.Core")]
[assembly: System.Reflection.AssemblyTitleAttribute("DotAigent.Core")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.

===== END OF FILE: ./src/DotAigent.Core/obj/Debug/netstandard2.0/DotAigent.Core.AssemblyInfo.cs =====

===== START OF FILE: ./src/DotAigent.Core/Agents/AgentBase.cs =====
namespace DotAigent.Core.Agents;

using DotAigent.Core;

/*public abstract class AgentBase(IModel model) : IAgent*/
/*{*/
/*    protected readonly IModel Model = model ?? throw new ArgumentNullException(nameof(model));*/
/**/
/*    public abstract Task<string> GenerateResponseAsync(string input);*/
/*}*/
===== END OF FILE: ./src/DotAigent.Core/Agents/AgentBase.cs =====

===== START OF FILE: ./src/DotAigent.Core/Agents/ChatBotAgent.cs =====


namespace DotAigent.Core.Agents;

// public class ChatbotAgent(IModel model, IEnumerable<ITool> tools, string? systemPrompt = null, string? outputFormat=null) : IAgent
// {
//     private readonly IEnumerable<ITool> _tools = tools;
//
//     public IEnumerable<ITool> Tools =>  _tools;
//
//     public async Task<AiAgentResponse> GenerateResponseAsync(string prompt)
//     {
//         try
//         {
//             return await model.GenerateResponseAsync(prompt, _tools, systemPrompt, outputFormat);
//         }
//         catch (Exception ex)
//         {
//             return new AiAgentResponse
//             {
//                 Success = false,
//                 ErrorMessage = ex.Message
//             };
//         }
//     }
//
// }



===== END OF FILE: ./src/DotAigent.Core/Agents/ChatBotAgent.cs =====

===== START OF FILE: ./src/DotAigent.Core/ToolParameter.cs =====
namespace DotAigent.Core;

/// <summary>
/// Describes a parameter that can be used with a tool, including its metadata.
/// </summary>
/// <param name="Name">The name of the parameter.</param>
/// <param name="Description">Human-readable description explaining the parameter's purpose.</param>
/// <param name="Type">The data type of the parameter (e.g., "string", "integer", "boolean").</param>
/// <param name="Required">Indicates whether the parameter must be provided when executing the tool.</param>
public record ToolParameterDescription(string Name, string Description, string Type, bool Required);

/// <summary>
/// Represents a parameter value passed to a tool during execution.
/// </summary>
/// <param name="Name">The name of the parameter, which should match a corresponding ToolParameterDescription.</param>
/// <param name="Value">The string representation of the parameter value to be used by the tool.</param>
public record ToolParameter(string Name, string Value);
===== END OF FILE: ./src/DotAigent.Core/ToolParameter.cs =====

===== START OF FILE: ./src/DotAigent.Core/IAgent.cs =====
namespace DotAigent.Core;

/// <summary>
/// Represents an AI agent that can process user inputs and generate responses.
/// This interface serves as the primary abstraction for agent implementations
/// that handle interaction between users and the underlying AI models.
/// </summary>
public interface IAgent
{
    
    /// <summary>
    /// Processes user input asynchronously and generates a response.
    /// </summary>
    /// <param name="prompt">The user's input text to be processed by the agent.</param>
    /// <returns>
    /// A task that resolves to the agent's response as a string.
    /// This typically includes the AI model's generated content, potentially
    /// enhanced by tool executions or other agent capabilities.
    /// </returns>
    Task<IAgentResponse<T>> GenerateResponseAsync<T>(string prompt) where T:class;

    /// <summary>
    /// The tools used by the agent.
    /// </summary>
    IEnumerable<ITool> Tools { get; }
}
===== END OF FILE: ./src/DotAigent.Core/IAgent.cs =====

===== START OF FILE: ./src/DotAigent.Core/ChatRole.cs =====
namespace DotAigent.Core;

/// <summary>
/// The role that is the origin of the message.
/// </summary>
public enum ChatRole
{

    /// <summary>
    /// The message is a system message.
    /// </summary>
    System,
    /// <summary>
    /// The message originated from the user.
    /// </summary>
    User,
    /// <summary>
    /// The message originated from the agent.
    /// </summary>
    Agent,
    /// <summary>
    /// The message originated from a tool.
    /// </summary>
    Tool
}

===== END OF FILE: ./src/DotAigent.Core/ChatRole.cs =====

===== START OF FILE: ./src/DotAigent.Core/IAgentResponse.cs =====
namespace DotAigent.Core;

/// <summary>
/// The response type from an agent.
/// </summary>
/// <typeparam name="T">The type of result data returned by the agent.</typeparam>
public interface IAgentResponse<T>
{
    /// <summary>
    /// Gets a value indicating whether the agent operation was successful.
    /// </summary>
    /// <value><c>true</c> if the operation succeeded; otherwise, <c>false</c>.</value>
    bool Success { get; }

    /// <summary>
    /// Gets the error message if the agent operation failed.
    /// </summary>
    /// <value>A string containing the error details when <see cref="Success"/> is <c>false</c>; otherwise an empty string.</value>
    string ErrorMessage { get; }

    /// <summary>
    /// Gets the collection of chat messages exchanged during the agent interaction.
    /// </summary>
    /// <value>An enumerable collection of <see cref="ChatMessage"/> objects representing the conversation history.</value>
    IEnumerable<ChatMessage> Messages { get; } 

    /// <summary>
    /// Gets the result data returned by the agent.
    /// </summary>
    /// <value>The result object of type <typeparamref name="T"/> if <see cref="Success"/> is <c>true</c>; otherwise <c>null</c>.</value>
    T? Result { get; }
}
===== END OF FILE: ./src/DotAigent.Core/IAgentResponse.cs =====

===== START OF FILE: ./src/DotAigent.Core/ChatMessage.cs =====
namespace DotAigent.Core;

/// <summary>
/// Represents a message in a chat conversation.
/// </summary>
public record ChatMessage
{
    /// <summary>
    /// Gets the role of the entity that sent this message.
    /// </summary>
    /// <value>The <see cref="ChatRole"/> indicating whether the message is from the system, user, agent, or tool.</value>
    public ChatRole Role { get; init; }
    
    /// <summary>
    /// Gets the content of the message.
    /// </summary>
    /// <value>The text content of the message. Empty string by default.</value>
    public string Message { get; init; } = string.Empty;
}

===== END OF FILE: ./src/DotAigent.Core/ChatMessage.cs =====

===== START OF FILE: ./src/DotAigent.Core/internal/ChatBotAgent.cs =====
namespace DotAigent.Core;

/// <summary>
/// Implementation of the IAgent interface providing chatbot functionality.
/// </summary>
/// <param name="provider">The provider used to generate AI responses.</param>
/// <param name="tools">Optional collection of tools available to the agent.</param>
/// <param name="systemPrompt">Optional system instructions to guide the AI model's behavior.</param>
internal class ChatbotAgent(IProvider provider, IEnumerable<ITool>? tools, string? systemPrompt) : IAgent
{
    private readonly IProvider _provider = provider;
    private readonly IEnumerable<ITool>? _tools = tools;
    private readonly string? _systemPrompt = systemPrompt;

    /// <inheritdoc />
    public IEnumerable<ITool> Tools => _tools ?? [];

    /// <inheritdoc />
    public Task<IAgentResponse<T>> GenerateResponseAsync<T>(string prompt) where T:class
    {
        return _provider.GenerateResponseAsync<T>(prompt, _systemPrompt, _tools);
    }
}
===== END OF FILE: ./src/DotAigent.Core/internal/ChatBotAgent.cs =====

===== START OF FILE: ./src/DotAigent.Core/IProvider.cs =====
namespace DotAigent.Core;

/// <summary>
/// Represents a provider for AI model services that can generate responses based on prompts.
/// </summary>
public interface IProvider
{
    /// <summary>
    /// Gets the name of the AI model used by this provider.
    /// </summary>
    /// <value>The string identifier of the model.</value>
    string ModelName { get; }
    
    /// <summary>
    /// Gets the endpoint URI for the AI service.
    /// </summary>
    /// <value>The URI of the service endpoint, or null if using default endpoints.</value>
    Uri? Endpoint { get; }

    /// <summary>
    /// Generates a response asynchronously based on the provided prompt.
    /// </summary>
    /// <typeparam name="T">The type of result to be returned by the agent.</typeparam>
    /// <param name="prompt">The user's prompt to send to the AI model.</param>
    /// <param name="systemPrompt">Optional system instructions to guide the AI model's behavior.</param>
    /// <param name="tools">Optional collection of tools that the AI can use when generating a response.</param>
    /// <returns>A task that resolves to an agent response containing the generated content.</returns>
    Task<IAgentResponse<T>> GenerateResponseAsync<T>(string prompt, string? systemPrompt = null, IEnumerable<ITool>? tools = null) where T:class;
}

===== END OF FILE: ./src/DotAigent.Core/IProvider.cs =====

===== START OF FILE: ./src/DotAigent.Core/ITool.cs =====
namespace DotAigent.Core;

public interface ITool
{
    /// <summary>
    /// Gets the name of the tool. This should be unique and descriptive.
    /// </summary>
    string Name { get; } 
    
    /// <summary>
    /// Gets the human-readable description of what the tool does.
    /// </summary>
    string Description { get; }
    
    /// <summary>
    /// Gets the parameters that this tool accepts, including their descriptions and constraints.
    /// </summary>
    IEnumerable<ToolParameterDescription> Parameters { get; }
}

/// <summary>
/// Interface representing a function-based tool that can be used by an AI agent to perform specific tasks.
/// </summary>
public interface IFunctionTool : ITool
{ 
    
    /// <summary>
    /// Executes the tool with the provided parameters.
    /// </summary>
    /// <param name="toolParameter">The collection of parameters to use when executing the tool.</param>
    /// <returns>A string result of the tool execution.</returns>
    Task<string> ExecuteAsync(IEnumerable<ToolParameter> toolParameter);
}

/// <summary>
/// Interface representing a tool that leverages another agent to perform tasks.
/// </summary>
public interface IAgentTool : ITool
{
    // This interface is currently empty but provides a type distinction for agent-based tools
}
===== END OF FILE: ./src/DotAigent.Core/ITool.cs =====

===== START OF FILE: ./src/DotAigent.Core/IAgentBuilder.cs =====
namespace DotAigent.Core;

public interface IAgentSupport
{
    /// <summary>
    /// Set the system prompt
    /// </summary>
    IAgentBuilder WithSystemPrompt(string systemPrompt);

    /// <summary>
    /// Agent use the provided tool
    /// </summary>
    IAgentBuilder UsingTool(ITool tool);
}

public interface IBuildSupport 
{
    /// <summary>
    /// Build the agent
    /// </summary>
    IAgent Build();
}

public interface IAgentBuilder : IAgentSupport, IProviderSupport {}

public interface IProviderBuilder: IBuildSupport {}

public interface IProviderSupport
{
     
    /// <summary>
    /// Use the specified provider, e.g. OpenAI, Google, Antrophic, etc.
    /// </summary>
    IProviderBuilder UsingProvider(IProvider provider);
}

/// <summary>
/// Agent builder
/// </summary>
public class AgentBuilder : IAgentBuilder,  IProviderBuilder
{
    private IProvider? _provider;
    private string? _systemPrompt;
    private readonly List<ITool> _tools =[];

    /// <inheritdoc />
    public IAgent Build()
    {
        var agent = new ChatbotAgent(
                _provider ?? throw new InvalidOperationException("Provider is required"),
                _tools, 
                _systemPrompt);

        return agent;
    }

    /// <inheritdoc />
    public IAgentBuilder WithSystemPrompt(string systemPrompt)
    {
        _systemPrompt = systemPrompt;
        return this;
    }

    /// <inheritdoc />
    public IAgentBuilder UsingTool(ITool tool)
    {
        _tools.Add(tool);
        return this;
    }

    /// <inheritdoc />
    public IProviderBuilder UsingProvider(IProvider provider)
    {
        _provider = provider;
        return this;
    }
}

===== END OF FILE: ./src/DotAigent.Core/IAgentBuilder.cs =====

===== START OF FILE: ./src/DotAigent.Core/AgentResponse.cs =====
using DotAigent.Core;

namespace DotAigent.Core;

public record AgentResponse<T> : IAgentResponse<T>
{
    public bool Success { get; init; }
    public string ErrorMessage { get; init; } = string.Empty;
    public IEnumerable<ChatMessage> Messages { get; init; } = [];
    public T? Result { get; init; }
}
===== END OF FILE: ./src/DotAigent.Core/AgentResponse.cs =====

===== START OF FILE: ./src/DotAigent.Core/AgentResponseAttribute.cs =====
namespace DotAigent.Core;

[AttributeUsage(AttributeTargets.Class)]
public sealed class AgentResponseAttribute : Attribute { }
===== END OF FILE: ./src/DotAigent.Core/AgentResponseAttribute.cs =====

===== START OF FILE: ./src/DotAigent.Core/IExample.cs =====
namespace DotAigent.Core;

/// <summary>
/// Represents an example JSON representation of a class.
/// </summary>
public interface IExample
{
    /// <summary>
    /// Example JSON representation of this class
    /// </summary>
    static string JsonExample { get; } = string.Empty;
}
===== END OF FILE: ./src/DotAigent.Core/IExample.cs =====

===== START OF FILE: ./src/DotAigent/obj/Debug/net9.0/DotAigent.GlobalUsings.g.cs =====
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
===== END OF FILE: ./src/DotAigent/obj/Debug/net9.0/DotAigent.GlobalUsings.g.cs =====

===== START OF FILE: ./src/DotAigent/obj/Debug/net9.0/.NETCoreApp,Version=v9.0.AssemblyAttributes.cs =====
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName = ".NET 9.0")]
===== END OF FILE: ./src/DotAigent/obj/Debug/net9.0/.NETCoreApp,Version=v9.0.AssemblyAttributes.cs =====

===== START OF FILE: ./src/DotAigent/obj/Debug/net9.0/generated/DotAigent.SourceGenerators/DotAigent.SourceGenerators.AgentResponseExampleGenerator/AgentSumOutput.g.cs =====
﻿using DotAigent.Core;
    public partial class AgentSumOutput : IExample
    {
        public static string JsonExample => @"{
    ""Sum"": 42
}";
    }
===== END OF FILE: ./src/DotAigent/obj/Debug/net9.0/generated/DotAigent.SourceGenerators/DotAigent.SourceGenerators.AgentResponseExampleGenerator/AgentSumOutput.g.cs =====

===== START OF FILE: ./src/DotAigent/obj/Debug/net9.0/DotAigent.AssemblyInfo.cs =====
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DotAiAgent")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+1a55f8e44862eb57d8097545997aa970c68057d0")]
[assembly: System.Reflection.AssemblyProductAttribute("DotAigent")]
[assembly: System.Reflection.AssemblyTitleAttribute("DotAigent")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.

===== END OF FILE: ./src/DotAigent/obj/Debug/net9.0/DotAigent.AssemblyInfo.cs =====

===== START OF FILE: ./src/DotAigent/Tools/CountryAgentTool.cs =====
//https://restcountries.com/v3.1/name/sweden

using DotAigent.Core;

namespace DotAigent.Tools;

public class CountryLookupTool : IFunctionTool
{
    public string Name => "LookupCountry";

    public IEnumerable<ToolParameterDescription> Parameters =>
        [
            new ToolParameterDescription("country_name", "The name of the country to lookup information about", "string", true),
        ];

    public string Description => "Looks up information about a country by name.";

    public async Task<string> ExecuteAsync(IEnumerable<ToolParameter> parameters)
    {
        var countryNameParameter = parameters.First(p => p.Name == "country_name").Value;

        string result = await LookupCountry(countryNameParameter);

        return result;
    }

    private async Task<string> LookupCountry(string countryNameParameter)
    {
            using (var client = new HttpClient())
            {
                // Get the webpage content as string
                string content = await client.GetStringAsync($"https://restcountries.com/v3.1/name/{countryNameParameter}");
                return content;
            }
    }
}
===== END OF FILE: ./src/DotAigent/Tools/CountryAgentTool.cs =====

===== START OF FILE: ./src/DotAigent/Tools/CalculatorTool.cs =====

using DotAigent.Core;

// public class AdditionToolAgent : IFunctionTool
// {
//     public string Name => "calculator_tool";
//
//     public string Description => "use this tool for calcluations like addition, subtraction, multiplication, division";
//
//     public IEnumerable<ToolParameterDescription> Parameters =>
//         [
//             new ToolParameterDescription("query", "Users query for calculation of the sum of two numbers", "string", true),
//         ];
//
//     public async Task<string> ExecuteAsync(IEnumerable<ToolParameter> toolParameters)
//     {
//         var agent = new AgentBuilder()
//         .UsingOpenAiApi()
//             /*.WithModelName("gpt-4o-mini")*/
//             .WithModelName("qwen2.5:14b")
//             .WithUri(new Uri("http://localhost:11434/v1")) // Local ollama
//             .WithTool(new AdditionCalculatorTool())
//         .Build();
//
//         /*Console.WriteLine($"Calculating the sum of two numbers using query {toolParameters}");*/
//         var query = toolParameters.FirstOrDefault(p => p.Name == "query")?.Value ?? throw new ArgumentException("Query must be provided");
//         /*Console.WriteLine($"Calculating the sum of two numbers using query {query}");*/
//         var result = await agent.GenerateResponseAsync(query);
//
//         /*Console.WriteLine($"TOOL: Calculating the sum of two numbers using query {query} equals {result.Result?.Message}");*/
//         if (!result.Success)
//             throw new InvalidOperationException($"Error in calculation, {result.ErrorMessage}");
//         return result.Result?.Message ?? throw new InvalidOperationException("Error in calculation");
//
//     }
// }
//
// public class AdditionCalculatorTool : IFunctionTool
// {
//     public string Name => "Add";
//
//     public IEnumerable<ToolParameterDescription> Parameters =>
//         [
//             new ToolParameterDescription("A", "First number to add.", "integer", true),
//             new ToolParameterDescription("B", "Second number to add.", "integer", true),
//         ];
//
//     public string Description => "Calculates the sum of two numbers.";
//
//     public Task<string> ExecuteAsync(IEnumerable<ToolParameter> parameters)
//     {
//         var firstNumberStr = parameters.First(p => p.Name == "A").Value;
//         var secondNumberStr = parameters.First(p => p.Name == "B").Value;
//
//         if (!double.TryParse(firstNumberStr, out double firstNumber))
//             throw new ArgumentException("A must be a number.");
//         if (!double.TryParse(secondNumberStr, out double secondNumber))
//             throw new ArgumentException("B must be a number.");
//         var result = firstNumber + secondNumber;
//
//         return Task.FromResult($"{result}");
//     }
// }
===== END OF FILE: ./src/DotAigent/Tools/CalculatorTool.cs =====

===== START OF FILE: ./src/DotAigent/AgentOutput.cs =====

using DotAigent.Core;

[AgentResponse]
public partial class AgentSumOutput
{
    public int Sum { get; set;}
}
===== END OF FILE: ./src/DotAigent/AgentOutput.cs =====

===== START OF FILE: ./src/DotAigent/Program.cs =====
﻿using DotAigent.Core;
using DotAigent.Providers.OpenAi;
using DotNetEnv;

internal partial class Program
{
    private static async Task Main(string[] args)
    {
        Env.Load();

        Console.WriteLine(AgentSumOutput.JsonExample);
        
    }
}


// var aent = new AgentBuilder2()
//     .WithSystemPrompt("some systemprompt")
//     .WithResultType<AgentDataOutput>()
//     .UsingTool(new GoogleSearchTool())
//     .UsingProvider(Provider.OpenAI)
//         .WithEndpoint(new Uri("http://localhost:11434"))
//         .WithModel("llama3.2:latest")
//     .Build();



internal class GoogleSearchTool : ITool
{
    public GoogleSearchTool()
    {
    }

    public string Name => throw new NotImplementedException();

    public string Description => throw new NotImplementedException();

    public IEnumerable<ToolParameterDescription> Parameters => throw new NotImplementedException();
}


// Agent
//     - SystemPrompt
//     - Tools
//     - StructuredResultType
//     - Model
//     - ModelSettings
//
// Model
//     - ModelName
//     - Provider (the service provider of the Model)
//     - Interface (The API endpoint type)
//
// Tool
//     - Structured Input
//     - ExecuteTool
//     - Structured Output
//
===== END OF FILE: ./src/DotAigent/Program.cs =====

===== START OF FILE: ./src/DotAigent.Providers/obj/Debug/net9.0/DotAigent.Providers.GlobalUsings.g.cs =====
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
===== END OF FILE: ./src/DotAigent.Providers/obj/Debug/net9.0/DotAigent.Providers.GlobalUsings.g.cs =====

===== START OF FILE: ./src/DotAigent.Providers/obj/Debug/net9.0/.NETCoreApp,Version=v9.0.AssemblyAttributes.cs =====
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName = ".NET 9.0")]
===== END OF FILE: ./src/DotAigent.Providers/obj/Debug/net9.0/.NETCoreApp,Version=v9.0.AssemblyAttributes.cs =====

===== START OF FILE: ./src/DotAigent.Providers/obj/Debug/net9.0/DotAigent.Providers.AssemblyInfo.cs =====
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DotAiAgent")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyDescriptionAttribute("Implements providers for DotAiAgent")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+1a55f8e44862eb57d8097545997aa970c68057d0")]
[assembly: System.Reflection.AssemblyProductAttribute("DotAigent.Providers")]
[assembly: System.Reflection.AssemblyTitleAttribute("DotAigent.Providers")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.

===== END OF FILE: ./src/DotAigent.Providers/obj/Debug/net9.0/DotAigent.Providers.AssemblyInfo.cs =====

===== START OF FILE: ./src/DotAigent.Providers/OpenAi/ChatMessageList.cs =====
using OpenAI.Chat;

namespace DotAigent.Providers.OpenAi;

public class ChatMessageList : List<ChatMessage>
{
    public void AddSystemMessage(string systemMessage)
    {
        Add(new SystemChatMessage(systemMessage));
    }

    public void AddUserMessage(string userMessage)
    {
        Add(new UserChatMessage(userMessage));
    }
}
===== END OF FILE: ./src/DotAigent.Providers/OpenAi/ChatMessageList.cs =====

===== START OF FILE: ./src/DotAigent.Providers/OpenAi/OpenAiProvider.cs =====
namespace DotAigent.Providers.OpenAi;

using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;
using DotAigent.Core;
using OpenAI;
using OpenAI.Chat;

public class OpenAIProvider(string modelName, string? apiKey = null, Uri? endpoint = null) : IProvider
{
    public string ModelName => modelName; 

    public Uri? Endpoint => endpoint;


    public async Task<IAgentResponse<T>> GenerateResponseAsync<T>(string prompt, string? systemPrompt, IEnumerable<ITool>? tools) where T : class
    {
        var messages = new ChatMessageList();
        var client = GetClient();
        string? jsonOutputFormat = null;

        systemPrompt ??= tools is not null ? "You are a helpful assistant and use the apropiate tool to solve the problem." : "You are a helpful assistant.";

        if (typeof(T) != typeof(string))
        {
            // We have a structured output. Lets get the output example json from type T
                // If no parameterless constructor exists (common with records), create a sample JSON structure
                var properties = typeof(T).GetProperties();
                var sampleObject = new Dictionary<string, object?>();
                
                foreach (var prop in properties)
                {
                    // Add sample values based on property type
                    var value = GetDefaultValueForType(prop.PropertyType);
                    sampleObject[prop.Name] = value;
                }
                jsonOutputFormat = JsonSerializer.Serialize(sampleObject);
        }

        // First we add the system message to the conversation.
        messages.AddSystemMessage(jsonOutputFormat is null ? systemPrompt : $"Only output json no other text.\nEXAMPLE OUTPUT: {jsonOutputFormat}");

        // Then we add the user prompt to the conversation.
        messages.AddUserMessage(prompt);

        // Get the chat client for the specified model.
        var chatClient = client.GetChatClient(modelName) ?? throw new ArgumentException($"Model not found {modelName}");

        ChatCompletionOptions options = GetChatCompletionOptions(tools, jsonOutputFormat);

        bool requiresAction;

        // Loop until the conversation is complete.
        do
        {
            requiresAction = false;
            ChatCompletion completion = await chatClient.CompleteChatAsync(messages, options);

            switch (completion.FinishReason)
            {
                case ChatFinishReason.Stop:
                    {
                        // Add the assistant message to the conversation history.
                        messages.Add(new AssistantChatMessage(completion));
                        break;
                    }

                case ChatFinishReason.ToolCalls:
                    {
                        // First, add the assistant message with tool calls to the conversation history.
                        messages.Add(new AssistantChatMessage(completion));

                        // Then, add a new tool message for each tool call that is resolved.
                        foreach (ChatToolCall toolCall in completion.ToolCalls)
                        {
                            var tool = tools?.FirstOrDefault(n => n.Name == toolCall.FunctionName) ?? throw new ArgumentException($"Tool not found: {toolCall.FunctionName}");

                            var result = tool switch
                            {
                                    IFunctionTool ftool  => await ftool.ExecuteAsync(GetToolParameters(toolCall)),
                                    _ => throw new ArgumentException($"Tool not found: {toolCall.FunctionName}")
                            };
                            messages.Add(new ToolChatMessage(toolCall.Id, result));
                        }

                        requiresAction = true;
                        break;
                    }

                case ChatFinishReason.Length:
                    throw new NotImplementedException("Incomplete model output due to MaxTokens parameter or token limit exceeded.");

                case ChatFinishReason.ContentFilter:
                    throw new NotImplementedException("Omitted content due to a content filter flag.");

                case ChatFinishReason.FunctionCall:
                    throw new NotImplementedException("Deprecated in favor of tool calls.");

                default:
                    throw new NotImplementedException(completion.FinishReason.ToString());
            }
        } while (requiresAction);

        List<Core.ChatMessage> responseMessages = FormatResponseMessages(messages);
        return new AgentResponse<T> { Success = true, Messages = responseMessages, Result = GetResult<T>(messages.Last()) };
    }

    /// <summary>
    /// Gets a default sample value for a given type to use in JSON structure examples.
    /// </summary>
    /// <param name="type">The type to generate a sample value for.</param>
    /// <returns>A sample value appropriate for the type.</returns>
    private static object? GetDefaultValueForType(Type type)
    {
        if (type == typeof(string))
            return "sample text";
        else if (type == typeof(int) || type == typeof(int?))
            return 0;
        else if (type == typeof(long) || type == typeof(long?))
            return 0L;
        else if (type == typeof(double) || type == typeof(double?))
            return 0.0;
        else if (type == typeof(decimal) || type == typeof(decimal?))
            return 0.0m;
        else if (type == typeof(bool) || type == typeof(bool?))
            return false;
        else if (type == typeof(DateTime) || type == typeof(DateTime?))
            return DateTime.Now.ToString("o");
        else if (type == typeof(Guid) || type == typeof(Guid?))
            return Guid.Empty.ToString();
        else if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(List<>))
            return Activator.CreateInstance(type);
        else if (type.IsEnum)
            return Enum.GetNames(type).FirstOrDefault() ?? Enum.GetValues(type).GetValue(0)?.ToString();
        else if (type.IsClass && type != typeof(object))
        {
            try
            {
                // For nested complex types, we return null to avoid infinite recursion
                return null;
            }
            catch
            {
                return null;
            }
        }
        else
            return null;
    }
    private T? GetResult<T>(OpenAI.Chat.ChatMessage completion)
    {
        var result = completion.Content.FirstOrDefault()?.Text;

        if (typeof(T) == typeof(string))
        {
            return (T?)(object?)result;
        }
        else
        {
            if (result is not null)
                return JsonSerializer.Deserialize<T>(result);
            else 
                return (T?)(object?)null;
        }
    }

    /// <summary>
    /// Extracts tool parameters from a tool call JSON.
    /// </summary>
    /// <param name="toolCall">The tool call containing function arguments.</param>
    /// <returns>An enumerable collection of tool parameters.</returns>
    private IEnumerable<ToolParameter> GetToolParameters(ChatToolCall toolCall)
    {
        var jsonDocument = JsonDocument.Parse(toolCall.FunctionArguments);
        // Iterate over the properties of the JSON object.
        foreach (JsonProperty property in jsonDocument.RootElement.EnumerateObject())
        {
            yield return new ToolParameter(property.Name, GetPropertyValue(property.Value));
        }


    }

    /// <summary>
    /// Converts a JsonElement to its string representation based on its kind.
    /// </summary>
    /// <param name="value">The JSON element to convert.</param>
    /// <returns>String representation of the JSON element.</returns>
    private string GetPropertyValue(JsonElement value)
    {
        return value.ValueKind switch
        {
            JsonValueKind.String => value.GetString() ?? "",
            JsonValueKind.Number => value.GetDouble().ToString(),
            JsonValueKind.True => "true",
            JsonValueKind.False => "false",
            JsonValueKind.Null => "null",
            _ => value.ToString(),
        };

    }

    /// <summary>
    /// Formats the OpenAI chat messages into a list of AiChatMessage objects.
    /// </summary>
    /// <param name="messages">The ChatMessageList containing all conversation messages.</param>
    /// <returns>A list of AiChatMessage objects formatted for the response.</returns>
    private static List<Core.ChatMessage> FormatResponseMessages(ChatMessageList messages)
    {
        List<Core.ChatMessage> responseMessages = [];
        foreach (OpenAI.Chat.ChatMessage message in messages)
        {
            switch (message)
            {
                case UserChatMessage userMessage:
                    responseMessages.Add(new Core.ChatMessage  { Role = ChatRole.User, Message = userMessage.Content[0].Text});
                    break;

                case AssistantChatMessage assistantMessage when assistantMessage.Content.Count > 0 && assistantMessage.Content[0].Text.Length > 0:
                    responseMessages.Add(new Core.ChatMessage { Role = ChatRole.Agent, Message = assistantMessage.Content[0].Text });
                    break;

                case ToolChatMessage tooltMessage when tooltMessage.Content.Count > 0 && tooltMessage.Content[0].Text.Length > 0:
                    responseMessages.Add(new Core.ChatMessage { Role = ChatRole.Tool, Message = tooltMessage.Content[0].Text });
                    break;
                case SystemChatMessage systemMessage:
                    responseMessages.Add(new Core.ChatMessage { Role = ChatRole.System, Message = systemMessage.Content[0].Text });
                    break;

                default:
                    break;
            }
        }
        return responseMessages;
    }

    /// <summary>
    /// Creates and configures chat completion options for the OpenAI API request.
    /// </summary>
    /// <returns>Configured chat completion options.</returns>
    private ChatCompletionOptions GetChatCompletionOptions(IEnumerable<ITool>? tools, string? jsonOutputFormat)
    {
        var options = new ChatCompletionOptions();
        if (tools is not null)
        {
            foreach (var tool in tools)
            {
                options.Tools.Add(GetChatTool(tool));
            }
        }
        if (jsonOutputFormat is not null)
            options.ResponseFormat = ChatResponseFormat.CreateJsonObjectFormat();
        return options;
    }

    /// <summary>
    /// Converts an ITool to a ChatTool for use with the OpenAI API.
    /// </summary>
    /// <param name="tool">The tool to convert.</param>
    /// <returns>A ChatTool representation of the input tool.</returns>
    private static ChatTool GetChatTool(ITool tool)
    {
        return ChatTool.CreateFunctionTool(
            functionName: tool.Name,
            functionDescription: tool.Description,
            functionParameters: GetFunctionParameters(tool.Parameters)
            );
    }

    /// <summary>
    /// Converts tool parameter descriptions to a binary data representation for API consumption.
    /// </summary>
    /// <param name="parameters">The tool parameter descriptions.</param>
    /// <returns>Binary data representing the function parameters schema.</returns>
    private static BinaryData GetFunctionParameters(IEnumerable<ToolParameterDescription> parameters)
    {
        if (!parameters.Any())
            return BinaryData.Empty;

        var required = parameters.Where(n => n.Required).Select(n => n.Name);
        var properties = parameters.Select(n =>
                new KeyValuePair<string, PropertySchema>(n.Name, new PropertySchema { Type = n.Type, Description = n.Description }));

        var schema = new Schema { Required = [.. required], Properties = properties.ToDictionary(n => n.Key, n => n.Value) };

        // Serialize the schema to a JSON string.
        string json = JsonSerializer.Serialize(schema);
        return BinaryData.FromString(json);

    }

    /// <summary>
    /// Creates or returns an existing OpenAI client.
    /// </summary>
    /// <returns>An OpenAI client instance.</returns>
    private OpenAIClient GetClient()
    {
        var options = new OpenAIClientOptions();
        var key = apiKey ?? Environment.GetEnvironmentVariable("OPENAI_API_KEY") ?? throw new InvalidOperationException("You have to provide an API key");

        if (Endpoint is not null)
            options.Endpoint = Endpoint;

        return new OpenAIClient(new(key), options: options);
    }
}

/// <summary>
/// Represents the schema of a property in a JSON schema.
/// </summary>
public record PropertySchema
{
    [JsonPropertyName("type")]
    public string Type { get; init; } = string.Empty;

    [JsonPropertyName("description")]
    public string Description { get; init; } = string.Empty;

}

/// <summary>
/// Represents a JSON schema for function parameters.
/// </summary>
public record Schema
{
    /// <summary>
    /// Gets the type of the schema. Default is "object".
    /// </summary>
    [JsonPropertyName("type")]
    public string Type { get; init; } = "object";

    /// <summary>
    /// Gets the dictionary of properties in the schema.
    /// </summary>
    [JsonPropertyName("properties")]
    public Dictionary<string, PropertySchema> Properties { get; init; } = [];

    /// <summary>
    /// Gets the array of required property names.
    /// </summary>
    [JsonPropertyName("required")]
    public string[] Required { get; init; } = [];
}
===== END OF FILE: ./src/DotAigent.Providers/OpenAi/OpenAiProvider.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/obj/Debug/netstandard2.0/DotAigent.SourceGenerators.GlobalUsings.g.cs =====
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
===== END OF FILE: ./src/DotAigent.SourceGenerators/obj/Debug/netstandard2.0/DotAigent.SourceGenerators.GlobalUsings.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/obj/Debug/netstandard2.0/.NETStandard,Version=v2.0.AssemblyAttributes.cs =====
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETStandard,Version=v2.0", FrameworkDisplayName = ".NET Standard 2.0")]
===== END OF FILE: ./src/DotAigent.SourceGenerators/obj/Debug/netstandard2.0/.NETStandard,Version=v2.0.AssemblyAttributes.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/obj/Debug/netstandard2.0/DotAigent.SourceGenerators.AssemblyInfo.cs =====
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DotAiAgent")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+1a55f8e44862eb57d8097545997aa970c68057d0")]
[assembly: System.Reflection.AssemblyProductAttribute("DotAigent.SourceGenerators")]
[assembly: System.Reflection.AssemblyTitleAttribute("DotAigent.SourceGenerators")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.

===== END OF FILE: ./src/DotAigent.SourceGenerators/obj/Debug/netstandard2.0/DotAigent.SourceGenerators.AssemblyInfo.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/obj/Debug/netstandard2.1/DotAigent.SourceGenerators.GlobalUsings.g.cs =====
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
===== END OF FILE: ./src/DotAigent.SourceGenerators/obj/Debug/netstandard2.1/DotAigent.SourceGenerators.GlobalUsings.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/obj/Debug/netstandard2.1/.NETStandard,Version=v2.1.AssemblyAttributes.cs =====
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETStandard,Version=v2.1", FrameworkDisplayName = ".NET Standard 2.1")]
===== END OF FILE: ./src/DotAigent.SourceGenerators/obj/Debug/netstandard2.1/.NETStandard,Version=v2.1.AssemblyAttributes.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/obj/Debug/netstandard2.1/DotAigent.SourceGenerators.AssemblyInfo.cs =====
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DotAiAgent")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+1256bbe36bffb6332199b1f27768895b18e883f1")]
[assembly: System.Reflection.AssemblyProductAttribute("DotAigent.SourceGenerators")]
[assembly: System.Reflection.AssemblyTitleAttribute("DotAigent.SourceGenerators")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.

===== END OF FILE: ./src/DotAigent.SourceGenerators/obj/Debug/netstandard2.1/DotAigent.SourceGenerators.AssemblyInfo.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/StringBuilderExtension.cs =====
using System.Text;

namespace DotAigent.SourceGenerators;

public static class StringBuilderExtension
{
    public static void AppendLineIndent(this StringBuilder sb, int indentLeve, string value)
    {
        for (int i = 0; i < indentLeve; i++)
        {
            sb.Append("    ");
        }
        sb.AppendLine(value);
    }
}
===== END OF FILE: ./src/DotAigent.SourceGenerators/StringBuilderExtension.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Diagnostics.CodeAnalysis.AllowNullAttribute.g.cs =====
﻿// <auto-generated/>
#pragma warning disable
#nullable enable annotations

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

namespace System.Diagnostics.CodeAnalysis
{
    /// <summary>
    /// Specifies that null is allowed as an input even if the corresponding type disallows it.
    /// </summary>
    [global::System.AttributeUsage(
        global::System.AttributeTargets.Field |
        global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Property,
        Inherited = false)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal sealed class AllowNullAttribute : global::System.Attribute
    {
    }
}===== END OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Diagnostics.CodeAnalysis.AllowNullAttribute.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Diagnostics.CodeAnalysis.ConstantExpectedAttribute.g.cs =====
﻿// <auto-generated/>
#pragma warning disable
#nullable enable annotations

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

namespace System.Diagnostics.CodeAnalysis
{
    /// <summary>
    /// Indicates that the specified method parameter expects a constant.
    /// </summary>
    /// <remarks>
    /// This can be used to inform tooling that a constant should be used as an argument for the annotated parameter.
    /// </remarks>
    [global::System.AttributeUsage(AttributeTargets.Parameter, Inherited = false)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal sealed class ConstantExpectedAttribute : global::System.Attribute
    {
        /// <summary>
        /// Indicates the minimum bound of the expected constant, inclusive.
        /// </summary>
        public object? Min { get; set; }

        /// <summary>
        /// Indicates the maximum bound of the expected constant, inclusive.
        /// </summary>
        public object? Max { get; set; }
    }
}===== END OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Diagnostics.CodeAnalysis.ConstantExpectedAttribute.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Diagnostics.CodeAnalysis.DisallowNullAttribute.g.cs =====
﻿// <auto-generated/>
#pragma warning disable
#nullable enable annotations

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

namespace System.Diagnostics.CodeAnalysis
{
    /// <summary>
    /// Specifies that null is disallowed as an input even if the corresponding type allows it.
    /// </summary>
    [global::System.AttributeUsage(
        global::System.AttributeTargets.Field |
        global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Property,
        Inherited = false)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal sealed class DisallowNullAttribute : global::System.Attribute
    {
    }
}===== END OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Diagnostics.CodeAnalysis.DisallowNullAttribute.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute.g.cs =====
﻿// <auto-generated/>
#pragma warning disable
#nullable enable annotations

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

namespace System.Diagnostics.CodeAnalysis
{
    /// <summary>
    /// Applied to a method that will never return under any circumstance.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method, Inherited = false)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal sealed class DoesNotReturnAttribute : global::System.Attribute
    {
    }
}===== END OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.g.cs =====
﻿// <auto-generated/>
#pragma warning disable
#nullable enable annotations

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

namespace System.Diagnostics.CodeAnalysis
{
    /// <summary>
    /// Specifies that the method will not return if the associated Boolean parameter is passed the specified value.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter, Inherited = false)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal sealed class DoesNotReturnIfAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes the attribute with the specified parameter value.
        /// </summary>
        /// <param name="parameterValue">
        /// The condition parameter value. Code after the method will be considered unreachable
        /// by diagnostics if the argument to the associated parameter matches this value.
        /// </param>
        public DoesNotReturnIfAttribute(bool parameterValue) => ParameterValue = parameterValue;

        /// <summary>
        /// Gets the condition parameter value.
        /// </summary>
        public bool ParameterValue { get; }
    }
}===== END OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Diagnostics.CodeAnalysis.ExperimentalAttribute.g.cs =====
﻿// <auto-generated/>
#pragma warning disable
#nullable enable annotations

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

namespace System.Diagnostics.CodeAnalysis
{
    /// <summary>
    /// Indicates that an API is experimental and it may change in the future.
    /// </summary>
    /// <remarks>
    /// This attribute allows call sites to be flagged with a diagnostic that indicates that an experimental
    /// feature is used. Authors can use this attribute to ship preview features in their assemblies.
    /// </remarks>
    [global::System.AttributeUsage(
        global::System.AttributeTargets.Assembly |
        global::System.AttributeTargets.Module |
        global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Struct |
        global::System.AttributeTargets.Enum |
        global::System.AttributeTargets.Constructor |
        global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Property |
        global::System.AttributeTargets.Field |
        global::System.AttributeTargets.Event |
        global::System.AttributeTargets.Interface |
        global::System.AttributeTargets.Delegate,
        Inherited = false)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal sealed class ExperimentalAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="global::System.Diagnostics.CodeAnalysis.ExperimentalAttribute"/> class,
        /// specifying the ID that the compiler will use when reporting a use of the API the attribute applies to.
        /// </summary>
        /// <param name="diagnosticId">The ID that the compiler will use when reporting a use of the API the attribute applies to.</param>
        public ExperimentalAttribute(string diagnosticId)
        {
            DiagnosticId = diagnosticId;
        }

        /// <summary>
        /// Gets the ID that the compiler will use when reporting a use of the API the attribute applies to.
        /// </summary>
        /// <value>The unique diagnostic ID.</value>
        /// <remarks>
        /// The diagnostic ID is shown in build output for warnings and errors.
        /// <para>This property represents the unique ID that can be used to suppress the warnings or errors, if needed.</para>
        /// </remarks>
        public string DiagnosticId { get; }

        /// <summary>
        /// Gets or sets the URL for corresponding documentation.
        /// The API accepts a format string instead of an actual URL, creating a generic URL that includes the diagnostic ID.
        /// </summary>
        /// <value>The format string that represents a URL to corresponding documentation.</value>
        /// <remarks>An example format string is <c>https://contoso.com/obsoletion-warnings/{0}</c>.</remarks>
        public string? UrlFormat { get; set; }
    }
}===== END OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Diagnostics.CodeAnalysis.ExperimentalAttribute.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Diagnostics.CodeAnalysis.MaybeNullAttribute.g.cs =====
﻿// <auto-generated/>
#pragma warning disable
#nullable enable annotations

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

namespace System.Diagnostics.CodeAnalysis
{
    /// <summary>
    /// Specifies that an output may be null even if the corresponding type disallows it.
    /// </summary>
    [global::System.AttributeUsage(
        global::System.AttributeTargets.Field |
        global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Property |
        global::System.AttributeTargets.ReturnValue,
        Inherited = false)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal sealed class MaybeNullAttribute : global::System.Attribute
    {
    }
}===== END OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Diagnostics.CodeAnalysis.MaybeNullAttribute.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.g.cs =====
﻿// <auto-generated/>
#pragma warning disable
#nullable enable annotations

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

namespace System.Diagnostics.CodeAnalysis
{
    /// <summary>
    /// Specifies that when a method returns <see cref="ReturnValue"/>, the parameter may be null even if the corresponding type disallows it.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter, Inherited = false)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal sealed class MaybeNullWhenAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes the attribute with the specified return value condition.
        /// </summary>
        /// <param name="returnValue">The return value condition. If the method returns this value, the associated parameter may be null.</param>
        public MaybeNullWhenAttribute(bool returnValue) => ReturnValue = returnValue;

        /// <summary>
        /// Gets the return value condition.
        /// </summary>
        public bool ReturnValue { get; }
    }
}===== END OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.g.cs =====
﻿// <auto-generated/>
#pragma warning disable
#nullable enable annotations

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

namespace System.Diagnostics.CodeAnalysis
{
    /// <summary>
    /// Specifies that the method or property will ensure that the listed field and property members have not-null values.
    /// </summary>
    [global::System.AttributeUsage(
        global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Property,
        Inherited = false, AllowMultiple = true)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal sealed class MemberNotNullAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes the attribute with a field or property member.
        /// </summary>
        /// <param name="member">The field or property member that is promised to be not-null.</param>
        public MemberNotNullAttribute(string member) => Members = new[] { member };

        /// <summary>
        /// Initializes the attribute with the list of field and property members.
        /// </summary>
        /// <param name="members">The list of field and property members that are promised to be not-null.</param>
        public MemberNotNullAttribute(params string[] members) => Members = members;

        /// <summary>
        /// Gets field or property member names.
        /// </summary>
        public string[] Members { get; }
    }
}===== END OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.g.cs =====
﻿// <auto-generated/>
#pragma warning disable
#nullable enable annotations

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

namespace System.Diagnostics.CodeAnalysis
{
    /// <summary>
    /// Specifies that the method or property will ensure that the listed field and property
    /// members have not-null values when returning with the specified return value condition.
    /// </summary>
    [global::System.AttributeUsage(
        global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Property,
        Inherited = false, AllowMultiple = true)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal sealed class MemberNotNullWhenAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes the attribute with the specified return value condition and a field or property member.
        /// </summary>
        /// <param name="returnValue">The return value condition. If the method returns this value, the associated parameter will not be null.</param>
        /// <param name="member">The field or property member that is promised to be not-null.</param>
        public MemberNotNullWhenAttribute(bool returnValue, string member)
        {
            ReturnValue = returnValue;
            Members = new[] { member };
        }

        /// <summary>
        /// Initializes the attribute with the specified return value condition and list of field and property members.
        /// </summary>
        /// <param name="returnValue">The return value condition. If the method returns this value, the associated parameter will not be null.</param>
        /// <param name="members">The list of field and property members that are promised to be not-null.</param>
        public MemberNotNullWhenAttribute(bool returnValue, params string[] members)
        {
            ReturnValue = returnValue;
            Members = members;
        }

        /// <summary>
        /// Gets the return value condition.
        /// </summary>
        public bool ReturnValue { get; }

        /// <summary>
        /// Gets field or property member names.
        /// </summary>
        public string[] Members { get; }
    }
}===== END OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Diagnostics.CodeAnalysis.NotNullAttribute.g.cs =====
﻿// <auto-generated/>
#pragma warning disable
#nullable enable annotations

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

namespace System.Diagnostics.CodeAnalysis
{
    /// <summary>
    /// Specifies that an output will not be null even if the corresponding type allows it.
    /// Specifies that an input argument was not null when the call returns.
    /// </summary>
    [global::System.AttributeUsage(
        global::System.AttributeTargets.Field |
        global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Property |
        global::System.AttributeTargets.ReturnValue,
        Inherited = false)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal sealed class NotNullAttribute : global::System.Attribute
    {
    }
}===== END OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Diagnostics.CodeAnalysis.NotNullAttribute.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.g.cs =====
﻿// <auto-generated/>
#pragma warning disable
#nullable enable annotations

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

namespace System.Diagnostics.CodeAnalysis
{
    /// <summary>
    /// Specifies that the output will be non-null if the named parameter is non-null.
    /// </summary>
    [global::System.AttributeUsage(
        global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Property |
        global::System.AttributeTargets.ReturnValue,
        AllowMultiple = true, Inherited = false)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal sealed class NotNullIfNotNullAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes the attribute with the associated parameter name.
        /// </summary>
        /// <param name="parameterName">The associated parameter name. The output will be non-null if the argument to the parameter specified is non-null.</param>
        public NotNullIfNotNullAttribute(string parameterName)
        {
            ParameterName = parameterName;
        }

        /// <summary>
        /// Gets the associated parameter name.
        /// </summary>
        public string ParameterName { get; }
    }
}===== END OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.g.cs =====
﻿// <auto-generated/>
#pragma warning disable
#nullable enable annotations

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

namespace System.Diagnostics.CodeAnalysis
{
    /// <summary>
    /// Specifies that when a method returns <see cref="ReturnValue"/>, the parameter will not be null even if the corresponding type allows it.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter, Inherited = false)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal sealed class NotNullWhenAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes the attribute with the specified return value condition.
        /// </summary>
        /// <param name="returnValue">The return value condition. If the method returns this value, the associated parameter will not be null.</param>
        public NotNullWhenAttribute(bool returnValue)
        {
            ReturnValue = returnValue;
        }

        /// <summary>Gets the return value condition.</summary>
        public bool ReturnValue { get; }
    }
}===== END OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute.g.cs =====
﻿// <auto-generated/>
#pragma warning disable
#nullable enable annotations

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

namespace System.Diagnostics.CodeAnalysis
{
    /// <summary>
    /// Specifies that this constructor sets all required members for the current type,
    /// and callers do not need to set any required members themselves.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Constructor, AllowMultiple = false, Inherited = false)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal sealed class SetsRequiredMembersAttribute : global::System.Attribute
    {
    }
}===== END OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.g.cs =====
﻿// <auto-generated/>
#pragma warning disable
#nullable enable annotations

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

namespace System.Diagnostics.CodeAnalysis
{
    /// <summary>
    /// Specifies the syntax used in a string.
    /// </summary>
    [global::System.AttributeUsage(
        global::System.AttributeTargets.Parameter |
        global::System.AttributeTargets.Field |
        global::System.AttributeTargets.Property,
        AllowMultiple = false, Inherited = false)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal sealed class StringSyntaxAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes the <see cref="global::System.Diagnostics.CodeAnalysis.StringSyntaxAttribute"/> with the identifier of the syntax used.
        /// </summary>
        /// <param name="syntax">The syntax identifier.</param>
        public StringSyntaxAttribute(string syntax)
        {
            Syntax = syntax;
            Arguments = new object?[0];
        }

        /// <summary>Initializes the <see cref="global::System.Diagnostics.CodeAnalysis.StringSyntaxAttribute"/> with the identifier of the syntax used.</summary>
        /// <param name="syntax">The syntax identifier.</param>
        /// <param name="arguments">Optional arguments associated with the specific syntax employed.</param>
        public StringSyntaxAttribute(string syntax, params object?[] arguments)
        {
            Syntax = syntax;
            Arguments = arguments;
        }

        /// <summary>Gets the identifier of the syntax used.</summary>
        public string Syntax { get; }

        /// <summary>Optional arguments associated with the specific syntax employed.</summary>
        public object?[] Arguments { get; }

        /// <summary>The syntax identifier for strings containing composite formats for string formatting.</summary>
        public const string CompositeFormat = nameof(CompositeFormat);

        /// <summary>The syntax identifier for strings containing date format specifiers.</summary>
        public const string DateOnlyFormat = nameof(DateOnlyFormat);

        /// <summary>The syntax identifier for strings containing date and time format specifiers.</summary>
        public const string DateTimeFormat = nameof(DateTimeFormat);

        /// <summary>The syntax identifier for strings containing <see cref="Enum"/> format specifiers.</summary>
        public const string EnumFormat = nameof(EnumFormat);

        /// <summary>The syntax identifier for strings containing <see cref="Guid"/> format specifiers.</summary>
        public const string GuidFormat = nameof(GuidFormat);

        /// <summary>The syntax identifier for strings containing JavaScript Object Notation (JSON).</summary>
        public const string Json = nameof(Json);

        /// <summary>The syntax identifier for strings containing numeric format specifiers.</summary>
        public const string NumericFormat = nameof(NumericFormat);

        /// <summary>The syntax identifier for strings containing regular expressions.</summary>
        public const string Regex = nameof(Regex);

        /// <summary>The syntax identifier for strings containing time format specifiers.</summary>
        public const string TimeOnlyFormat = nameof(TimeOnlyFormat);

        /// <summary>The syntax identifier for strings containing <see cref="global::System.TimeSpan"/> format specifiers.</summary>
        public const string TimeSpanFormat = nameof(TimeSpanFormat);

        /// <summary>The syntax identifier for strings containing URIs.</summary>
        public const string Uri = nameof(Uri);

        /// <summary>The syntax identifier for strings containing XML.</summary>
        public const string Xml = nameof(Xml);
    }
}===== END OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Diagnostics.CodeAnalysis.UnscopedRefAttribute.g.cs =====
﻿// <auto-generated/>
#pragma warning disable
#nullable enable annotations

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

namespace System.Diagnostics.CodeAnalysis
{
    /// <summary>
    /// Used to indicate a byref escapes and is not scoped.
    /// </summary>
    /// <remarks>
    /// <para>
    /// There are several cases where the C# compiler treats a <see langword="ref"/> as implicitly
    /// <see langword="scoped"/> - where the compiler does not allow the <see langword="ref"/> to escape the method.
    /// </para>
    /// <para>
    /// For example:
    /// <list type="number">
    ///     <item><see langword="this"/> for <see langword="struct"/> instance methods.</item>
    ///     <item><see langword="ref"/> parameters that refer to <see langword="ref"/> <see langword="struct"/> types.</item>
    ///     <item><see langword="out"/> parameters.</item>
    /// </list>
    /// </para>
    /// <para>
    /// This attribute is used in those instances where the <see langword="ref"/> should be allowed to escape.
    /// </para>
    /// <para>
    /// Applying this attribute, in any form, has impact on consumers of the applicable API. It is necessary for
    /// API authors to understand the lifetime implications of applying this attribute and how it may impact their users.
    /// </para>
    /// </remarks>
    [global::System.AttributeUsage(
        global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Property |
        global::System.AttributeTargets.Parameter,
        AllowMultiple = false,
        Inherited = false)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal sealed class UnscopedRefAttribute : global::System.Attribute
    {
    }
}===== END OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Diagnostics.CodeAnalysis.UnscopedRefAttribute.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Index.g.cs =====
﻿// <auto-generated/>
#pragma warning disable
#nullable enable annotations

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

namespace System
{
    /// <summary>Represent a type can be used to index a collection either from the start or the end.</summary>
    /// <remarks>
    /// Index is used by the C# compiler to support the new index syntax
    /// <code>
    /// int[] someArray = new int[5] { 1, 2, 3, 4, 5 } ;
    /// int lastElement = someArray[^1]; // lastElement = 5
    /// </code>
    /// </remarks>
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal readonly struct Index : global::System.IEquatable<global::System.Index>
    {
        private readonly int _value;

        /// <summary>Construct an Index using a value and indicating if the index is from the start or from the end.</summary>
        /// <param name="value">The index value. it has to be zero or positive number.</param>
        /// <param name="fromEnd">Indicating if the index is from the start or from the end.</param>
        /// <remarks>
        /// If the Index constructed from the end, index value 1 means pointing at the last element and index value 0 means pointing at beyond last element.
        /// </remarks>
        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public Index(int value, bool fromEnd = false)
        {
            if (value < 0)
            {
                global::System.Index.ThrowHelper.ThrowValueArgumentOutOfRange_NeedNonNegNumException();
            }

            if (fromEnd)
                _value = ~value;
            else
                _value = value;
        }

        // The following private constructors mainly created for perf reason to avoid the checks
        private Index(int value)
        {
            _value = value;
        }

        /// <summary>Create an Index pointing at first element.</summary>
        public static global::System.Index Start => new global::System.Index(0);

        /// <summary>Create an Index pointing at beyond last element.</summary>
        public static global::System.Index End => new global::System.Index(~0);

        /// <summary>Create an Index from the start at the position indicated by the value.</summary>
        /// <param name="value">The index value from the start.</param>
        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static global::System.Index FromStart(int value)
        {
            if (value < 0)
            {
                global::System.Index.ThrowHelper.ThrowValueArgumentOutOfRange_NeedNonNegNumException();
            }

            return new global::System.Index(value);
        }

        /// <summary>Create an Index from the end at the position indicated by the value.</summary>
        /// <param name="value">The index value from the end.</param>
        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static global::System.Index FromEnd(int value)
        {
            if (value < 0)
            {
                global::System.Index.ThrowHelper.ThrowValueArgumentOutOfRange_NeedNonNegNumException();
            }

            return new global::System.Index(~value);
        }

        /// <summary>Returns the index value.</summary>
        public int Value
        {
            get
            {
                if (_value < 0)
                    return ~_value;
                else
                    return _value;
            }
        }

        /// <summary>Indicates whether the index is from the start or the end.</summary>
        public bool IsFromEnd => _value < 0;

        /// <summary>Calculate the offset from the start using the giving collection length.</summary>
        /// <param name="length">The length of the collection that the Index will be used with. length has to be a positive value</param>
        /// <remarks>
        /// For performance reason, we don't validate the input length parameter and the returned offset value against negative values.
        /// we don't validate either the returned offset is greater than the input length.
        /// It is expected Index will be used with collections which always have non negative length/count. If the returned offset is negative and
        /// then used to index a collection will get out of range exception which will be same affect as the validation.
        /// </remarks>
        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public int GetOffset(int length)
        {
            int offset = _value;
            if (IsFromEnd)
            {
                // offset = length - (~value)
                // offset = length + (~(~value) + 1)
                // offset = length + value + 1

                offset += length + 1;
            }
            return offset;
        }

        /// <summary>Indicates whether the current Index object is equal to another object of the same type.</summary>
        /// <param name="value">An object to compare with this object</param>
        public override bool Equals([global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] object? value) => value is global::System.Index && _value == ((global::System.Index)value)._value;

        /// <summary>Indicates whether the current Index object is equal to another Index object.</summary>
        /// <param name="other">An object to compare with this object</param>
        public bool Equals(global::System.Index other) => _value == other._value;

        /// <summary>Returns the hash code for this instance.</summary>
        public override int GetHashCode() => _value;

        /// <summary>Converts integer number to an Index.</summary>
        public static implicit operator global::System.Index(int value) => FromStart(value);

        /// <summary>Converts the value of the current Index object to its equivalent string representation.</summary>
        public override string ToString()
        {
            if (IsFromEnd)
                return ToStringFromEnd();

            return ((uint)Value).ToString();
        }

        private string ToStringFromEnd()
        {
            return '^' + Value.ToString();
        }

        private static class ThrowHelper
        {
            [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]
            public static void ThrowValueArgumentOutOfRange_NeedNonNegNumException()
            {
                throw new global::System.ArgumentOutOfRangeException("value", "Non-negative number required.");
            }
        }
    }
}===== END OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Index.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Range.g.cs =====
﻿// <auto-generated/>
#pragma warning disable
#nullable enable annotations

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

namespace System
{
    /// <summary>Represent a range has start and end indexes.</summary>
    /// <remarks>
    /// Range is used by the C# compiler to support the range syntax.
    /// <code>
    /// int[] someArray = new int[5] { 1, 2, 3, 4, 5 };
    /// int[] subArray1 = someArray[0..2]; // { 1, 2 }
    /// int[] subArray2 = someArray[1..^0]; // { 2, 3, 4, 5 }
    /// </code>
    /// </remarks>
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal readonly struct Range : global::System.IEquatable<global::System.Range>
    {
        /// <summary>Represent the inclusive start index of the Range.</summary>
        public global::System.Index Start { get; }

        /// <summary>Represent the exclusive end index of the Range.</summary>
        public global::System.Index End { get; }

        /// <summary>Construct a Range object using the start and end indexes.</summary>
        /// <param name="start">Represent the inclusive start index of the range.</param>
        /// <param name="end">Represent the exclusive end index of the range.</param>
        public Range(global::System.Index start, global::System.Index end)
        {
            Start = start;
            End = end;
        }

        /// <summary>Indicates whether the current Range object is equal to another object of the same type.</summary>
        /// <param name="value">An object to compare with this object</param>
        public override bool Equals([global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] object? value) =>
            value is global::System.Range r &&
            r.Start.Equals(Start) &&
            r.End.Equals(End);

        /// <summary>Indicates whether the current Range object is equal to another Range object.</summary>
        /// <param name="other">An object to compare with this object</param>
        public bool Equals(global::System.Range other) => other.Start.Equals(Start) && other.End.Equals(End);

        /// <summary>Returns the hash code for this instance.</summary>
        public override int GetHashCode()
        {
            return global::System.Range.HashHelpers.Combine(Start.GetHashCode(), End.GetHashCode());
        }

        /// <summary>Converts the value of the current Range object to its equivalent string representation.</summary>
        public override string ToString()
        {
            return Start.ToString() + ".." + End.ToString();
        }

        /// <summary>Create a Range object starting from start index to the end of the collection.</summary>
        public static global::System.Range StartAt(global::System.Index start) => new global::System.Range(start, global::System.Index.End);

        /// <summary>Create a Range object starting from first element in the collection to the end Index.</summary>
        public static global::System.Range EndAt(global::System.Index end) => new global::System.Range(global::System.Index.Start, end);

        /// <summary>Create a Range object starting from first element to the end.</summary>
        public static global::System.Range All => new global::System.Range(global::System.Index.Start, global::System.Index.End);

        /// <summary>Calculate the start offset and length of range object using a collection length.</summary>
        /// <param name="length">The length of the collection that the range will be used with. length has to be a positive value.</param>
        /// <remarks>
        /// For performance reason, we don't validate the input length parameter against negative values.
        /// It is expected Range will be used with collections which always have non negative length/count.
        /// We validate the range is inside the length scope though.
        /// </remarks>
        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public (int Offset, int Length) GetOffsetAndLength(int length)
        {
            int start;
            global::System.Index startIndex = Start;
            if (startIndex.IsFromEnd)
                start = length - startIndex.Value;
            else
                start = startIndex.Value;

            int end;
            global::System.Index endIndex = End;
            if (endIndex.IsFromEnd)
                end = length - endIndex.Value;
            else
                end = endIndex.Value;

            if ((uint)end > (uint)length || (uint)start > (uint)end)
            {
                global::System.Range.ThrowHelper.ThrowArgumentOutOfRangeException();
            }

            return (start, end - start);
        }

        private static class HashHelpers
        {
            public static int Combine(int h1, int h2)
            {
                uint rol5 = ((uint)h1 << 5) | ((uint)h1 >> 27);
                return ((int)rol5 + h1) ^ h2;
            }
        }

        private static class ThrowHelper
        {
            [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]
            public static void ThrowArgumentOutOfRangeException()
            {
                throw new global::System.ArgumentOutOfRangeException("length");
            }
        }
    }
}===== END OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Range.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Runtime.CompilerServices.CallerArgumentExpressionAttribute.g.cs =====
﻿// <auto-generated/>
#pragma warning disable
#nullable enable annotations

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

namespace System.Runtime.CompilerServices
{
    /// <summary>
    /// An attribute that allows parameters to receive the expression of other parameters.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal sealed class CallerArgumentExpressionAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="global::System.Runtime.CompilerServices.CallerArgumentExpressionAttribute"/> class.
        /// </summary>
        /// <param name="parameterName">The condition parameter value.</param>
        public CallerArgumentExpressionAttribute(string parameterName)
        {
            ParameterName = parameterName;
        }

        /// <summary>
        /// Gets the parameter name the expression is retrieved from.
        /// </summary>
        public string ParameterName { get; }
    }
}===== END OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Runtime.CompilerServices.CallerArgumentExpressionAttribute.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Runtime.CompilerServices.CollectionBuilderAttribute.g.cs =====
﻿// <auto-generated/>
#pragma warning disable
#nullable enable annotations

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

namespace System.Runtime.CompilerServices
{
    [global::System.AttributeUsage(
        global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Struct |
        global::System.AttributeTargets.Interface,
        Inherited = false)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal sealed class CollectionBuilderAttribute : Attribute
    {
        /// <summary>
        /// Initialize the attribute to refer to the <paramref name="methodName"/> method on the <paramref name="builderType"/> type.
        /// </summary>
        /// <param name="builderType">The type of the builder to use to construct the collection.</param>
        /// <param name="methodName">The name of the method on the builder to use to construct the collection.</param>
        /// <remarks>
        /// <paramref name="methodName"/> must refer to a static method that accepts a single parameter of
        /// type <see cref="ReadOnlySpan{T}"/> and returns an instance of the collection being built containing
        /// a copy of the data from that span.  In future releases of .NET, additional patterns may be supported.
        /// </remarks>
        public CollectionBuilderAttribute(Type builderType, string methodName)
        {
            BuilderType = builderType;
            MethodName = methodName;
        }

        /// <summary>
        /// Gets the type of the builder to use to construct the collection.
        /// </summary>
        public Type BuilderType { get; }

        /// <summary>
        /// Gets the name of the method on the builder to use to construct the collection.
        /// </summary>
        /// <remarks>
        /// This should match the metadata name of the target method.
        /// For example, this might be ".ctor" if targeting the type's constructor.
        /// </remarks>
        public string MethodName { get; }
    }
}===== END OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Runtime.CompilerServices.CollectionBuilderAttribute.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.g.cs =====
﻿// <auto-generated/>
#pragma warning disable
#nullable enable annotations

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

namespace System.Runtime.CompilerServices
{
    /// <summary>
    /// Indicates that compiler support for a particular feature is required for the location where this attribute is applied.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.All, AllowMultiple = true, Inherited = false)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal sealed class CompilerFeatureRequiredAttribute : global::System.Attribute
    {
        /// <summary>
        /// Creates a new instance of the <see cref="global::System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute"/> type.
        /// </summary>
        /// <param name="featureName">The name of the feature to indicate.</param>
        public CompilerFeatureRequiredAttribute(string featureName)
        {
            FeatureName = featureName;
        }

        /// <summary>
        /// The name of the compiler feature.
        /// </summary>
        public string FeatureName { get; }

        /// <summary>
        /// If true, the compiler can choose to allow access to the location where this attribute is applied if it does not understand <see cref="FeatureName"/>.
        /// </summary>
        public bool IsOptional { get; set; }

        /// <summary>
        /// The <see cref="FeatureName"/> used for the ref structs C# feature.
        /// </summary>
        public const string RefStructs = nameof(RefStructs);

        /// <summary>
        /// The <see cref="FeatureName"/> used for the required members C# feature.
        /// </summary>
        public const string RequiredMembers = nameof(RequiredMembers);
    }
}===== END OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.g.cs =====
﻿// <auto-generated/>
#pragma warning disable
#nullable enable annotations

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

namespace System.Runtime.CompilerServices
{
    /// <summary>
    /// Indicates which arguments to a method involving an interpolated string handler should be passed to that handler.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal sealed class InterpolatedStringHandlerArgumentAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="global::System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute"/> class.
        /// </summary>
        /// <param name="argument">The name of the argument that should be passed to the handler.</param>
        /// <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        public InterpolatedStringHandlerArgumentAttribute(string argument)
        {
            Arguments = new string[] { argument };
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="global::System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute"/> class.
        /// </summary>
        /// <param name="arguments">The names of the arguments that should be passed to the handler.</param>
        /// <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        public InterpolatedStringHandlerArgumentAttribute(params string[] arguments)
        {
            Arguments = arguments;
        }

        /// <summary>
        /// Gets the names of the arguments that should be passed to the handler.
        /// </summary>
        /// <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        public string[] Arguments { get; }
    }
}
===== END OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute.g.cs =====
﻿// <auto-generated/>
#pragma warning disable
#nullable enable annotations

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

namespace System.Runtime.CompilerServices
{
    /// <summary>
    /// Indicates the attributed type is to be used as an interpolated string handler.
    /// </summary>
    [global::System.AttributeUsage(
        global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Struct,
        AllowMultiple = false, Inherited = false)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal sealed class InterpolatedStringHandlerAttribute : global::System.Attribute
    {
    }
}===== END OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Runtime.CompilerServices.IsExternalInit.g.cs =====
﻿// <auto-generated/>
#pragma warning disable
#nullable enable annotations

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

namespace System.Runtime.CompilerServices
{
    /// <summary>
    /// Reserved to be used by the compiler for tracking metadata.
    /// This class should not be used by developers in source code.
    /// </summary>
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal static class IsExternalInit
    {
    }
}===== END OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Runtime.CompilerServices.IsExternalInit.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Runtime.CompilerServices.ModuleInitializerAttribute.g.cs =====
﻿// <auto-generated/>
#pragma warning disable
#nullable enable annotations

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

namespace System.Runtime.CompilerServices
{
    /// <summary>
    /// Used to indicate to the compiler that a method should be called
    /// in its containing module's initializer.
    /// </summary>
    /// <remarks>
    /// When one or more valid methods
    /// with this attribute are found in a compilation, the compiler will
    /// emit a module initializer which calls each of the attributed methods.
    ///
    /// Certain requirements are imposed on any method targeted with this attribute:
    /// - The method must be `static`.
    /// - The method must be an ordinary member method, as opposed to a property accessor, constructor, local function, etc.
    /// - The method must be parameterless.
    /// - The method must return `void`.
    /// - The method must not be generic or be contained in a generic type.
    /// - The method's effective accessibility must be `internal` or `public`.
    ///
    /// The specification for module initializers in the .NET runtime can be found here:
    /// https://github.com/dotnet/runtime/blob/main/docs/design/specs/Ecma-335-Augments.md#module-initializer
    /// </remarks>
    [global::System.AttributeUsage(global::System.AttributeTargets.Method, Inherited = false)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal sealed class ModuleInitializerAttribute : global::System.Attribute
    {
    }
}===== END OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Runtime.CompilerServices.ModuleInitializerAttribute.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute.g.cs =====
﻿// <auto-generated/>
#pragma warning disable
#nullable enable annotations

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

namespace System.Runtime.CompilerServices
{
    /// <summary>
    /// Specifies the priority of a member in overload resolution. When unspecified, the default priority is 0.
    /// </summary>
    [global::System.AttributeUsage(
        global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Constructor |
        global::System.AttributeTargets.Property,
        AllowMultiple = false,
        Inherited = false)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal sealed class OverloadResolutionPriorityAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="global::System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute"/> class.
        /// </summary>
        /// <param name="priority">The priority of the attributed member. Higher numbers are prioritized, lower numbers are deprioritized. 0 is the default if no attribute is present.</param>
        public OverloadResolutionPriorityAttribute(int priority)
        {
            Priority = priority;
        }

        /// <summary>
        /// The priority of the member.
        /// </summary>
        public int Priority { get; }
    }
}===== END OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Runtime.CompilerServices.ParamCollectionAttribute.g.cs =====
﻿// <auto-generated/>
#pragma warning disable
#nullable enable annotations

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

namespace System.Runtime.CompilerServices
{
    /// <summary>
    /// Indicates that a method will allow a variable number of arguments in its invocation.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter, Inherited = true, AllowMultiple = false)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal sealed class ParamCollectionAttribute : global::System.Attribute
    {
    }
}===== END OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Runtime.CompilerServices.ParamCollectionAttribute.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Runtime.CompilerServices.RequiredMemberAttribute.g.cs =====
﻿// <auto-generated/>
#pragma warning disable
#nullable enable annotations

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

namespace System.Runtime.CompilerServices
{
    /// <summary>
    /// Specifies that a type has required members or that a member is required.
    /// </summary>
    [global::System.AttributeUsage(
        global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Struct |
        global::System.AttributeTargets.Field |
        global::System.AttributeTargets.Property,
        AllowMultiple = false,
        Inherited = false)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal sealed class RequiredMemberAttribute : global::System.Attribute
    {
    }
}===== END OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Runtime.CompilerServices.RequiredMemberAttribute.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Runtime.CompilerServices.RequiresLocationAttribute.g.cs =====
﻿// <auto-generated/>
#pragma warning disable
#nullable enable annotations

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

namespace System.Runtime.CompilerServices
{
    /// <summary>
    /// Reserved for use by a compiler for tracking metadata.
    /// This attribute should not be used by developers in source code.
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter, Inherited = false)]
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal sealed class RequiresLocationAttribute : global::System.Attribute
    {
    }
}===== END OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Runtime.CompilerServices.RequiresLocationAttribute.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Runtime.CompilerServices.SkipLocalsInitAttribute.g.cs =====
﻿// <auto-generated/>
#pragma warning disable
#nullable enable annotations

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

namespace System.Runtime.CompilerServices
{
    /// <summary>
    /// Used to indicate to the compiler that the <c>.locals init</c> flag should not be set in method headers.
    /// </summary>
    [global::System.AttributeUsage(
        global::System.AttributeTargets.Module |
        global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Struct |
        global::System.AttributeTargets.Interface |
        global::System.AttributeTargets.Constructor |
        global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Property |
        global::System.AttributeTargets.Event,
        Inherited = false)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal sealed class SkipLocalsInitAttribute : global::System.Attribute
    {
    }
}===== END OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Runtime.CompilerServices.SkipLocalsInitAttribute.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Runtime.Versioning.RequiresPreviewFeaturesAttribute.g.cs =====
﻿// <auto-generated/>
#pragma warning disable
#nullable enable annotations

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

namespace System.Runtime.Versioning
{
    [global::System.AttributeUsage(
        global::System.AttributeTargets.Assembly |
        global::System.AttributeTargets.Module |
        global::System.AttributeTargets.Class |
        global::System.AttributeTargets.Interface |
        global::System.AttributeTargets.Delegate |
        global::System.AttributeTargets.Struct |
        global::System.AttributeTargets.Enum |
        global::System.AttributeTargets.Constructor |
        global::System.AttributeTargets.Method |
        global::System.AttributeTargets.Property |
        global::System.AttributeTargets.Field |
        AttributeTargets.Event, Inherited = false)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal sealed class RequiresPreviewFeaturesAttribute : global::System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="global::System.Runtime.Versioning.RequiresPreviewFeaturesAttribute"/> class.
        /// </summary>
        public RequiresPreviewFeaturesAttribute()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="global::System.Runtime.Versioning.RequiresPreviewFeaturesAttribute"/> class with the specified message.
        /// </summary>
        /// <param name="message">An optional message associated with this attribute instance.</param>
        public RequiresPreviewFeaturesAttribute(string? message)
        {
            Message = message;
        }

        /// <summary>
        /// Returns the optional message associated with this attribute instance.
        /// </summary>
        public string? Message { get; }

        /// <summary>
        /// Returns the optional URL associated with this attribute instance.
        /// </summary>
        public string? Url { get; set; }
    }
}===== END OF FILE: ./src/DotAigent.SourceGenerators/Generated/PolySharp.SourceGenerators/PolySharp.SourceGenerators.PolyfillsGenerator/System.Runtime.Versioning.RequiresPreviewFeaturesAttribute.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators/ExampleGenerator.cs =====
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Text;

namespace DotAigent.SourceGenerators;

[Generator]
public class AgentResponseExampleGenerator : IIncrementalGenerator
{
    private static void Log(string message)
    {
        string logFilePath = Path.Combine("/home/thhel/", "incremental_generator.log");
        File.AppendAllText(logFilePath, $"{DateTime.Now}: {message}{Environment.NewLine}");
    }
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        try
        {
            var pipeline = context.SyntaxProvider.ForAttributeWithMetadataName(
                        fullyQualifiedMetadataName: "DotAigent.Core.AgentResponseAttribute",
                        predicate: static (syntaxNode, cancellationToken) => syntaxNode is ClassDeclarationSyntax cds && cds.AttributeLists.Count > 0,
                        transform: static (context, cancellationToken) =>
                        {
                            try
                            {
                                var model = new Model(
                                 // Note: this is a simplified example. You will also need to handle the case where the type is in a global namespace, nested, etc.
                                 context.TargetSymbol.ContainingNamespace?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted)),
                                 context.TargetSymbol.Name,
                                 GenerateJsonExample(context.TargetSymbol as INamedTypeSymbol));
                                Log($"Model: {model}");
                                return model;
                            }
                            catch (Exception e)
                            {
                                Log($"Error: {e}");
                                throw;
                            }
                        }
                    );
            context.RegisterSourceOutput(pipeline, static (context, model) =>
            {
                try
                {
                    Log("Source called");
                    var codeBuilder = new StringBuilder();

                    codeBuilder.AppendLine("using DotAigent.Core;");

                    if (!string.IsNullOrEmpty(model.Namespace))
                    {
                        codeBuilder.AppendLine($"namespace {model.Namespace}");
                        codeBuilder.AppendLine("{");
                    }
                    codeBuilder.AppendLineIndent(1, $"public partial class {model.ClassName} : IExample");
                    codeBuilder.AppendLineIndent(1, "{");
                    codeBuilder.AppendLineIndent(2, $"public static string JsonExample => {model.JsonExample};");

                    codeBuilder.AppendLineIndent(1, "}");
                    if (!string.IsNullOrEmpty(model.Namespace))
                    {
                        codeBuilder.AppendLine("}");
                    }

                    var sourceText = SourceText.From(codeBuilder.ToString(), Encoding.UTF8);

                    context.AddSource($"{model.ClassName}.g.cs", sourceText);

                }
                catch (Exception e)
                {
                    Log($"Error: {e}");
                    throw;
                }
            });
        }
        catch (Exception e)
        {
            Log($"Error: {e}");
            throw;
        }
    }

    private static string GenerateJsonExample(INamedTypeSymbol classSymbol)
    {
        var properties = classSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.GetMethod != null && p.GetMethod.DeclaredAccessibility == Accessibility.Public)
            .ToList();

        if (properties.Count == 0)
            return "@\"{}\"";

        var jsonLines = properties.Select(p => $"    \"\"{p.Name}\"\": {GetExampleValue(p.Type)}");
        return "@\"{\n" + string.Join(",\n", jsonLines) + "\n}\"";
    }

    private static string GetExampleValue(ITypeSymbol type)
    {
        return type.SpecialType switch
        {
            SpecialType.System_Int32 => "42",
            SpecialType.System_String => "\"example\"",
            SpecialType.System_Boolean => "true",
            SpecialType.System_Double => "3.14",
            _ => "null"
        };
    }

}
internal class Model(string namespaceName, string className, string jsonExample)
{
    public string Namespace { get; } = namespaceName;
    public string ClassName { get; } = className;
    public string JsonExample { get; } = jsonExample;
}

//     public void Execute(GeneratorExecutionContext context)
//     {
//         // Retrieve the syntax receiver
//         if (context.SyntaxReceiver is not SyntaxReceiver receiver || receiver.CandidateClasses.Count == 0)
//             return;
//
//         // Get the compilation and attribute symbol
//         var compilation = context.Compilation;
//         var attributeSymbol = compilation.GetTypeByMetadataName(AttributeName);
//         if (attributeSymbol == null)
//             return; // Attribute not found in compilation
//
//         // Collect classes with the attribute
//         var classesWithAttribute = new List<INamedTypeSymbol>();
//         foreach (var candidate in receiver.CandidateClasses)
//         {
//             var model = compilation.GetSemanticModel(candidate.SyntaxTree);
//             if (model.GetDeclaredSymbol(candidate) is INamedTypeSymbol classSymbol && classSymbol.GetAttributes().Any(ad => SymbolEqualityComparer.Default.Equals(ad.AttributeClass, attributeSymbol)))
//             {
//                 classesWithAttribute.Add(classSymbol);
//             }
//         }
//
//         if (classesWithAttribute.Count == 0)
//             return;
//
//         // Generate the source code
//         var ifStatements = new List<string>();
//         foreach (var classSymbol in classesWithAttribute)
//         {
//             var fullyQualifiedName = classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
//             var jsonString = GenerateJsonString(classSymbol);
//             ifStatements.Add($"if (typeof(T) == typeof({fullyQualifiedName}))\n                return {jsonString};");
//         }
//
//         var methodBody = ifStatements.Count != 0
//             ? string.Join("\n            else ", ifStatements) + "\n            else\n                throw new NotSupportedException($\"No example for type {{typeof(T)}}\");"
//             : "throw new NotSupportedException($\"No example for type {typeof(T)}\");";
//
//         var source = $@"
// using System;
// using System.CodeDom.Compiler;
//
// namespace DotAigent.Generated
// {{
//     [GeneratedCode(""DotAigent.SourceGenerators.AgentResponseExampleGenerator"", ""1.0.0.0"")]
//     public static class ResponseExamples
//     {{
//         public static string GetExample<T>() where T : class
//         {{
//             {methodBody}
//         }}
//     }}
// }}";
//
//         context.AddSource("ResponseExamples.g.cs", SourceText.From(source, Encoding.UTF8));
//     }
//
//     private static string GenerateJsonString(INamedTypeSymbol classSymbol)
//     {
//         var properties = classSymbol.GetMembers()
//             .OfType<IPropertySymbol>()
//             .Where(p => p.GetMethod != null && p.GetMethod.DeclaredAccessibility == Accessibility.Public)
//             .ToList();
//
//         if (properties.Count == 0)
//             return "@\"{}\"";
//
//         var jsonLines = properties.Select(p => $"    \"\"{p.Name}\"\": {GetExampleValue(p.Type)}");
//         return "@\"{\n" + string.Join(",\n", jsonLines) + "\n}\"";
//     }
//
//     private static string GetExampleValue(ITypeSymbol type)
//     {
//         return type.SpecialType switch
//         {
//             SpecialType.System_Int32 => "42",
//             SpecialType.System_String => "\"example\"",
//             SpecialType.System_Boolean => "true",
//             SpecialType.System_Double => "3.14",
//             _ => "null"
//         };
//     }
// }
===== END OF FILE: ./src/DotAigent.SourceGenerators/ExampleGenerator.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators.Test/obj/Debug/net9.0/DotAigent.SourceGenerators.Test.GlobalUsings.g.cs =====
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
global using global::Xunit;
===== END OF FILE: ./src/DotAigent.SourceGenerators.Test/obj/Debug/net9.0/DotAigent.SourceGenerators.Test.GlobalUsings.g.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators.Test/obj/Debug/net9.0/.NETCoreApp,Version=v9.0.AssemblyAttributes.cs =====
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName = ".NET 9.0")]
===== END OF FILE: ./src/DotAigent.SourceGenerators.Test/obj/Debug/net9.0/.NETCoreApp,Version=v9.0.AssemblyAttributes.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators.Test/obj/Debug/net9.0/DotAigent.SourceGenerators.Test.AssemblyInfo.cs =====
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DotAiAgent")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+1a55f8e44862eb57d8097545997aa970c68057d0")]
[assembly: System.Reflection.AssemblyProductAttribute("DotAigent.SourceGenerators.Test")]
[assembly: System.Reflection.AssemblyTitleAttribute("DotAigent.SourceGenerators.Test")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.

===== END OF FILE: ./src/DotAigent.SourceGenerators.Test/obj/Debug/net9.0/DotAigent.SourceGenerators.Test.AssemblyInfo.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators.Test/UnitTest1.cs =====
﻿using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Testing;
using Microsoft.CodeAnalysis.Testing.Verifiers;

namespace DotAigent.SourceGenerators.Test;

// public static class CSharpSourceGeneratorVerifier<TSourceGenerator>
//     where TSourceGenerator : IIncrementalGenerator, new()
// {
//     public class Test : CSharpSourceGeneratorTest<TSourceGenerator, XUnitVerifier>
//     {
//         public Test()
//         {
//         }
//
//         protected override CompilationOptions CreateCompilationOptions()
//         {
//             var compilationOptions = base.CreateCompilationOptions();
//             return compilationOptions.WithSpecificDiagnosticOptions(
//                  compilationOptions.SpecificDiagnosticOptions.SetItems(GetNullableWarningsFromCompiler()));
//         }
//
//         public LanguageVersion LanguageVersion { get; set; } = LanguageVersion.Default;
//
//         private static ImmutableDictionary<string, ReportDiagnostic> GetNullableWarningsFromCompiler()
//         {
//             string[] args = { "/warnaserror:nullable" };
//             var commandLineArguments = CSharpCommandLineParser.Default.Parse(args, baseDirectory: Environment.CurrentDirectory, sdkDirectory: Environment.CurrentDirectory);
//             var nullableWarnings = commandLineArguments.CompilationOptions.SpecificDiagnosticOptions;
//
//             return nullableWarnings;
//         }
//
//         protected override ParseOptions CreateParseOptions()
//         {
//             return ((CSharpParseOptions)base.CreateParseOptions()).WithLanguageVersion(LanguageVersion);
//         }
//     }
// }

// public class UnitTest1
// {
//     private const string _exampleClassDefinition = """
//         namespace GeneratorTests;
//
//         public partial class ExampleClass 
//         {
//             public int Sum { get; }
//         }
//         """;
//
//     private static Compilation CreateCompilation(params string[] source)
//     {
//         var path = Path.GetDirectoryName(typeof(object).Assembly.Location)!;
//         var runtimeAssemblyPath = Path.Combine(path, "System.Runtime.dll");
//
//         var runtimeReference = MetadataReference.CreateFromFile(typeof(object).Assembly.Location);
//
//         return CSharpCompilation.Create("compilation",
//                 source.Select(s => CSharpSyntaxTree.ParseText(s)),
//                 [
//                     MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
//                     MetadataReference.CreateFromFile(runtimeAssemblyPath),
//                     // MetadataReference.CreateFromFile(typeof(IServiceCollection).Assembly.Location),
//                     // MetadataReference.CreateFromFile(typeof(External.IExternalService).Assembly.Location),
//                 ],
//                 new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));
//     }
//
//     // [Fact]
//     // public void StaticMethodReturningServices()
//     // {
//     //     var compilation = CreateCompilation(_exampleClassDefinition,
//     //         """
//     //         using ServiceScan.SourceGenerator;
//     //         using Microsoft.Extensions.DependencyInjection;
//     //
//     //         namespace GeneratorTests;
//     //
//     //         public static partial class ServicesExtensions
//     //         {
//     //             [GenerateServiceRegistrations(AssignableTo = typeof(IService))]
//     //             public static partial IServiceCollection AddServices(IServiceCollection services);
//     //         }
//     //         """);
//     //
//     //     var results = CSharpGeneratorDriver
//     //         .Create(_generator)
//     //         .RunGenerators(compilation)
//     //         .GetRunResult();
//     //
//     //     var expected = """
//     //         using Microsoft.Extensions.DependencyInjection;
//     //
//     //         namespace GeneratorTests;
//     //
//     //         public static partial class ServicesExtensions
//     //         {
//     //             public static partial IServiceCollection AddServices( IServiceCollection services)
//     //             {
//     //                 return services
//     //                     .AddTransient<GeneratorTests.IService, GeneratorTests.MyService>();
//     //             }
//     //         }
//     //         """;
//     //
//     //     Assert.Equal(expected, results.GeneratedTrees[1].ToString());
//     // }
//     [Fact]
//     public void Test1()
//     {
//             var userSource = 
//             """
//             namespace GeneratorTests;
//
//             public partial class ExampleClass 
//             {
//                 public int Sum { get; }
//             }
//             """;
//
//         var syntaxTree = CSharpSyntaxTree.ParseText(userSource);
//             var references = new[]
//             {
//                 MetadataReference.CreateFromFile(typeof(object).Assembly.Location) // System.Private.CoreLib
//             };
//
//             var compilation = CSharpCompilation.Create(
//                 "TestCompilation",
//                 [syntaxTree],
//                 references,
//                 new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary)
//             );
//         var driver = CSharpGeneratorDriver.Create(new AgentResponseExampleGenerator());
//         driver.RunGeneratorsAndUpdateCompilation(compilation, out var outputCompilation, out var diagnostics);
//
//         // Step 3: Verify results
//             Assert.Empty(diagnostics); // No errors or warnings
//             Assert.Equal(2, outputCompilation.SyntaxTrees.Count()); // Original + generated
//
//         // Step 4: Check the generated code
//         var generatedTree = outputCompilation.SyntaxTrees.ElementAt(1); // Skip the original source
//         var generatedCode = generatedTree.ToString();
//         var expected = 
//             """
//             using DotAigent.Core;
//                 public partial class AgentSumOutput : IExample
//                 {
//                     public static string JsonExample => @"{
//                 ""Sum"": 42
//             }";
//                 }
//             """;
//         // var source = results.Results[0].GeneratedSources.Single().SourceText.ToString();
//         Assert.Equal(expected, generatedCode);
//
//     }
// }
===== END OF FILE: ./src/DotAigent.SourceGenerators.Test/UnitTest1.cs =====

===== START OF FILE: ./src/DotAigent.SourceGenerators.Test/SomteTest.cs =====
using Xunit;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Testing;
using Microsoft.CodeAnalysis.Testing.Verifiers;
using System.Threading.Tasks;

// Adjust namespace as needed
namespace DotAigent.SourceGenerators.Tests;

// Use your actual generator type here
using GeneratorUnderTest = DotAigent.SourceGenerators.AgentResponseExampleGenerator;

public class AgentResponseExampleGeneratorTests
    : CSharpSourceGeneratorTest<GeneratorUnderTest, XUnitVerifier>
{
    // --- Define AttributeSource and InterfaceSource constants here as shown above ---
    private const string AttributeSource = @"..."; // As above
    private const string InterfaceSource = @"..."; // As above

    private static string GetBoilerplate(string userSource) =>
        AttributeSource + "\n" + InterfaceSource + "\n" + userSource;

    // Basic test case: Class in a namespace with supported properties
    [Fact]
    public async Task GeneratesExample_ForClassInNamespace_WithSupportedProperties()
    {
        var userSource = @"
using DotAigent.Core;

namespace MyTestApp
{
    [AgentResponse]
    public partial class UserProfileResponse
    {
        public int UserId { get; set; }
        public string UserName { get; set; } = ""Default""; // Initializer doesn't matter for generation
        public bool IsActive { get; set; }
        public double Score { get; set; }
        private string InternalData { get; set; } // Should be ignored
        public int ReadOnlyProperty { get; }      // Should be included if public getter
    }
}
";

        var expectedGeneratedSource = @"// <auto-generated/>
using DotAigent.Core;

namespace MyTestApp
{
    public partial class UserProfileResponse : IExample
    {
        public static string JsonExample => @""{
    ""UserId"": 42,
    ""UserName"": ""example"",
    ""IsActive"": true,
    ""Score"": 3.14,
    ""ReadOnlyProperty"": 42
}"";
    }
}
";
        // Combine boilerplate and user source
        var fullInputSource = GetBoilerplate(userSource);

        // Use the testing helper to run the generator and verify output
        await VerifySourceGeneratorAsync(
            fullInputSource,
            ("UserProfileResponse.g.cs", expectedGeneratedSource) // Just filename and source
        );
    }

    // Test case: Class in the global namespace
    [Fact]
    public async Task GeneratesExample_ForClassInGlobalNamespace()
    {
        var userSource = @"
using DotAigent.Core;

[AgentResponse]
public partial class GlobalResponse
{
    public string Message { get; set; }
}
";

        var expectedGeneratedSource = @"// <auto-generated/>
using DotAigent.Core;

public partial class GlobalResponse : IExample
{
    public static string JsonExample => @""{
    ""Message"": ""example""
}"";
}
";
        var fullInputSource = GetBoilerplate(userSource);

        // Call the revised helper:
        await VerifySourceGeneratorAsync(
            fullInputSource,
            ("GlobalResponse.g.cs", expectedGeneratedSource) // Just filename and source
        );
    }

    // Test case: Class with unsupported property types
    [Fact]
    public async Task GeneratesExample_WithNullForUnsupportedTypes()
    {
        var userSource = @"
using DotAigent.Core;
using System; // For DateTime

namespace TestSpace
{
    [AgentResponse]
    public partial class ComplexResponse
    {
        public DateTime Timestamp { get; set; } // Unsupported, should be null
        public Guid RequestId { get; set; }     // Unsupported, should be null
        public int Count { get; set; }          // Supported
    }
}
";

        var expectedGeneratedSource = @"// <auto-generated/>
using DotAigent.Core;

namespace TestSpace
{
    public partial class ComplexResponse : IExample
    {
        public static string JsonExample => @""{
    ""Timestamp"": null,
    ""RequestId"": null,
    ""Count"": 42
}"";
    }
}
";

        var fullInputSource = GetBoilerplate(userSource);
        // Call the revised helper:
        await VerifySourceGeneratorAsync(
            fullInputSource,
            ("ComplexResponseResponse.g.cs", expectedGeneratedSource) // Just filename and source
        );

    }
    [Fact]
    public async Task GeneratesEmptyJsonObject_ForClassWithNoPublicProperties()
    {
            var userSource = @"
    using DotAigent.Core;

    namespace TestEmpty
    {
        [AgentResponse]
        public partial class EmptyResponse
        {
            private int _hidden;
            protected string ProtectedData { get; set; }
            internal object InternalThing { get; set; }
            public EmptyResponse(int hidden) { _hidden = hidden; } // Constructor
        }
    }
    ";

            var expectedGeneratedSource = @"// <auto-generated/>
    using DotAigent.Core;

    namespace TestEmpty
    {
        public partial class EmptyResponse : IExample
        {
            public static string JsonExample => @""{}"";
        }
    }
    ";
        // ... (userSource and expectedGeneratedSource remain the same) ...
        var fullInputSource = GetBoilerplate(userSource);

        // Call the revised helper:
        await VerifySourceGeneratorAsync(
            fullInputSource,
            ("EmptyResponse.g.cs", expectedGeneratedSource) // Just filename and source
        );
    }
    //     // Test case: Class with no public properties
    //     [Fact]
    //     public async Task GeneratesEmptyJsonObject_ForClassWithNoPublicProperties()
    //     {
    //         var userSource = @"
    // using DotAigent.Core;
    //
    // namespace TestEmpty
    // {
    //     [AgentResponse]
    //     public partial class EmptyResponse
    //     {
    //         private int _hidden;
    //         protected string ProtectedData { get; set; }
    //         internal object InternalThing { get; set; }
    //         public EmptyResponse(int hidden) { _hidden = hidden; } // Constructor
    //     }
    // }
    // ";
    //
    //         var expectedGeneratedSource = @"// <auto-generated/>
    // #nullable enable
    //
    // using DotAigent.Core;
    //
    // namespace TestEmpty
    // {
    //     public partial class EmptyResponse : IExample
    //     {
    //         public static string JsonExample => @""{}"";
    //     }
    // }
    // ";
    //         var fullInputSource = GetBoilerplate(userSource);
    //
    //         await VerifySourceGeneratorAsync(
    //             fullInputSource,
    //             ("AgentResponseExampleGenerator", "EmptyResponse.g.cs", expectedGeneratedSource)
    //         );
    //     }

    // Test case: No attribute applied
    [Fact]
    public async Task DoesNotGenerate_WhenAttributeIsMissing()
    {
        // This class does NOT have the [AgentResponse] attribute
        var userSource = @"
namespace NoAttributeTest
{
    public partial class SomeOtherClass
    {
        public string Name { get; set; }
    }
}
";
        var fullInputSource = GetBoilerplate(userSource);

        // Expect no source files to be generated by our specific generator
        await VerifySourceGeneratorAsync(fullInputSource /*, No expected outputs */);
    }

    // Test case: Multiple classes with the attribute
    [Fact]
    public async Task GeneratesExamples_ForMultipleClasses()
    {
        var userSource = @"
using DotAigent.Core;

namespace MultiTest
{
    [AgentResponse]
    public partial class FirstResponse
    {
        public int Id { get; set; }
    }

    // Another class without the attribute - should be ignored
    public class IgnoredClass { }

    [AgentResponse]
    public partial class SecondResponse
    {
        public string Value { get; set; }
    }
}
";

        var expectedGeneratedSource1 = @"// <auto-generated/>
using DotAigent.Core;

namespace MultiTest
{
    public partial class FirstResponse : IExample
    {
        public static string JsonExample => @""{
    ""Id"": 42
}"";
    }
}
";
        var expectedGeneratedSource2 = @"// <auto-generated/>
using DotAigent.Core;

namespace MultiTest
{
    public partial class SecondResponse : IExample
    {
        public static string JsonExample => @""{
    ""Value"": ""example""
}"";
    }
}
";
        var fullInputSource = GetBoilerplate(userSource);

        // await VerifySourceGeneratorAsync(
        //     fullInputSource,
        //     ("AgentResponseExampleGenerator", "FirstResponse.g.cs", expectedGeneratedSource1),
        //     ("AgentResponseExampleGenerator", "SecondResponse.g.cs", expectedGeneratedSource2)
        // );
    }
    // --- Helper Method ---
    // Wraps the core verification logic for cleaner tests
    // Takes only filename and source pairs for the generator under test.
    private Task VerifySourceGeneratorAsync(string source, params (string filename, string generatedSource)[] expected)
    {
        var test = new CSharpSourceGeneratorTest<GeneratorUnderTest, XUnitVerifier>
        {
            TestState =
        {
            Sources = { source },
            // Ensure you have necessary references if not defaulted correctly
            // E.g., if DotAigent.Core is in a separate project/assembly:
            // ReferenceAssemblies = ReferenceAssemblies.Default.AddPackages(ImmutableArray.Create(/* potentially needed NuGet packages */))
            //                                                .AddAssemblies(ImmutableArray.Create(typeof(DotAigent.Core.AgentResponseAttribute).Assembly.Location)) // Add assembly explicitly if needed
        },
        };

        // Add expected outputs, associating them explicitly with our GeneratorUnderTest type
        foreach (var (filename, generatedSource) in expected)
        {
            test.TestState.GeneratedSources.Add(
                (typeof(GeneratorUnderTest), filename, generatedSource) // Use typeof here!
            );
        }

        // Optionally clear default generators if they interfere (usually not needed unless debugging specific issues)
        // test.TestState.GeneratedSources.Clear();

        return test.RunAsync();
    }
    // // --- Helper Method ---
    // // Wraps the core verification logic for cleaner tests
    // private Task VerifySourceGeneratorAsync(string source, params (string generatorName, string filename, string generatedSource)[] expected)
    // {
    //     var test = new CSharpSourceGeneratorTest<GeneratorUnderTest, XUnitVerifier>
    //     {
    //         TestState =
    //         {
    //             Sources = { source },
    //         },
    //     };
    //
    //     foreach (var (generatorName, filename, generatedSource) in expected)
    //     {
    //         // Find the specific generator assembly if needed, otherwise often inferred.
    //         // Adjust the generator name if your generator assembly name is different.
    //         test.TestState.GeneratedSources.Add(
    //             (typeof(GeneratorUnderTest), filename, generatedSource)
    //         );
    //     }
    //
    //     // Optionally: Disable default generated sources if they interfere
    //     // test.TestState.GeneratedSources.Clear(); // Use if default generators cause issues
    //
    //     // ReferenceAssemblies can be customized if needed, but often defaults are okay
    //     // test.ReferenceAssemblies = ...;
    //
    //     return test.RunAsync();
    // }
}
===== END OF FILE: ./src/DotAigent.SourceGenerators.Test/SomteTest.cs =====

